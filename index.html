<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Classroom Defense — Math Game v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React 18 UMD -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel for JSX-in-browser -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      html,body{height:100%} body{background:#eef2ff}
      .errbox{position:fixed;bottom:12px;left:12px;right:12px;background:#fee2e2;color:#7f1d1d;border:1px solid #ef4444;border-radius:12px;padding:10px;font:14px/1.3 system-ui,Segoe UI,Roboto}
      .errbox pre{white-space:pre-wrap;margin:6px 0 0}
    </style>
  </head>
  <body>
    <noscript>This game needs JavaScript enabled.</noscript>
    <div id="root"></div>

    <!-- Crash overlay (shows errors instead of blank page) -->
    <script>
      (function(){
        function showErr(title, detail){
          var box=document.createElement('div'); box.className='errbox';
          box.innerHTML='<b>'+title+'</b><pre>'+detail+'</pre>';
          document.body.appendChild(box);
        }
        window.addEventListener('error', function(e){
          try{ showErr('Script error:', (e.message||'') + '\n' + (e.filename||'') + ':' + (e.lineno||'') ); }catch(_){}
        });
        window.addEventListener('unhandledrejection', function(e){
          try{ showErr('Unhandled promise rejection:', String(e.reason)); }catch(_){}
        });
        // Polyfill randomUUID for older browsers
        if (!window.crypto) window.crypto = {};
        if (typeof window.crypto.randomUUID !== 'function') {
          window.crypto.randomUUID = function(){
            // lightweight RFC4122-ish fallback
            const s = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c=>{
              const r = Math.random()*16|0, v = c==='x'? r : (r&0x3|0x8);
              return v.toString(16);
            });
            return s;
          };
        }
      })();
    </script>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      // --- constants ---
      const TOWER_TYPES = { PENCIL:"PENCIL", ERASER:"ERASER", CALCULATOR:"CALCULATOR", RULER:"RULER" };
      const ENEMY_TYPES = { HOMEWORK:"HOMEWORK", QUIZ:"QUIZ", TEST:"TEST", FINAL:"FINAL" };

      const MAP_W = 900, MAP_H = 540;
      const PATH = [
        { x: 40, y: 100 }, { x: 220, y: 100 }, { x: 220, y: 60 },  { x: 360, y: 60 },
        { x: 360, y: 180 }, { x: 520, y: 180 }, { x: 520, y: 320 }, { x: 320, y: 320 },
        { x: 320, y: 420 }, { x: 640, y: 420 }, { x: 640, y: 280 }, { x: 800, y: 280 },
        { x: 860, y: 360 }
      ];

      const TOTAL_WAVES = 50;

      // helpers
      function lerp(a,b,t){return a+(b-a)*t}
      function distance(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}
      function clamp(n,lo,hi){return Math.max(lo, Math.min(hi,n))}
      function formatCoins(n){return Math.floor(n)}
      function pathLength(pts){let L=0; for(let i=0;i<pts.length-1;i++) L+=distance(pts[i],pts[i+1]); return L}
      const PATH_LENGTH = pathLength(PATH);
      function pointAtT(pts,t){
        let target=t*PATH_LENGTH, acc=0;
        for(let i=0;i<pts.length-1;i++){
          const a=pts[i], b=pts[i+1], seg=distance(a,b);
          if(acc+seg>=target){ const local=(target-acc)/seg; return {x: lerp(a.x,b.x,local), y: lerp(a.y,b.y,local)} }
          acc+=seg;
        }
        return pts[pts.length-1];
      }

      // balance (harder, no spawn lock)
      function enemyStats(type,wave, endlessBoost=0){
        const s = (1 + wave*0.09) * (1 + endlessBoost);
        switch(type){
          case ENEMY_TYPES.HOMEWORK: return { hp:18*s, speed:0.055, reward:3 };
          case ENEMY_TYPES.QUIZ:     return { hp:36*s, speed:0.043, reward:7 };
          case ENEMY_TYPES.TEST:     return { hp:85*s, speed:0.034, reward:14 };
          case ENEMY_TYPES.FINAL:    return { hp:320*s, speed:0.030, reward:45 };
          default:                   return { hp:20, speed:0.04, reward:5 };
        }
      }
      function baseTowerStats(kind, level=1){
        const L=clamp(level,1,3);
        if(kind===TOWER_TYPES.PENCIL)     return { range:115+10*L, dmg:5+2*L,  fireRate:630-30*L, name:["Pencil","Pen","Marker"][L-1] };
        if(kind===TOWER_TYPES.ERASER)     return { range:135+12*L, dmg:12+4*L, fireRate:880-40*L, name:["Eraser","Board Eraser","Giant Sponge"][L-1] };
        if(kind===TOWER_TYPES.CALCULATOR) return { range:150+14*L, dmg:8+1*L,  fireRate:400-15*L, chain:2+(L-1), name:["Calculator","Sci Calc","Graphing Calc"][L-1] };
        if(kind===TOWER_TYPES.RULER)      return { range:190+22*L, dmg:10+3*L, fireRate:760-60*L, pierce:1+L, name:["Ruler","Yardstick","Tape Measure"][L-1] };
        return { range:100, dmg:5, fireRate:800, name:"" };
      }
      const BASE_COST = { PENCIL:20, ERASER:35, CALCULATOR:45, RULER:60 };
      function upgradeCost(level){ return 40 + level*45 }

      // classroom decor
      function ClassroomDecor(){
        return (
          <>
            <rect x={40} y={10} width={300} height={36} rx={6} fill="#083344" stroke="#052e2b" strokeWidth="2"/>
            <text x={190} y={34} textAnchor="middle" fontSize="16" fill="#bbf7d0">Room 207 — Geometry</text>
            {[...Array(6)].map((_,i)=>(<rect key={i} x={0} y={80+i*70} width={28} height={56} rx={4} fill="#3b82f6" stroke="#1d4ed8"/>))}
            {
              [{x:260,y:120},{x:420,y:120},{x:580,y:120},
               {x:260,y:260},{x:420,y:260},{x:580,y:260},
               {x:260,y:400},{x:420,y:400},{x:700,y:360}]
              .map((d,idx)=>(
                <g key={idx}>
                  <rect x={d.x} y={d.y} width={70} height={40} rx={6} fill="#f1f5f9" stroke="#94a3b8"/>
                  <circle cx={d.x+10} cy={d.y+36} r={3} fill="#64748b"/>
                </g>
              ))
            }
            <ellipse cx={830} cy={420} rx={70} ry={28} fill="#fde68a" opacity="0.5"/>
          </>
        );
      }

      // tower sprites (by level)
      function TowerSprite({ kind, level=1, x, y, scale=1, opacity=1 }){
        const s = scale;
        if(kind === TOWER_TYPES.PENCIL){
          if(level===1){ // Pencil
            return (
              <g opacity={opacity} transform={`translate(${x-12*s},${y-12*s}) scale(${s})`}>
                <rect x={2} y={6} width={20} height={12} rx={2} fill="#f59e0b" stroke="#92400e"/>
                <polygon points="22,6 30,12 22,18" fill="#fde68a" stroke="#92400e"/>
                <polygon points="30,12 32,12 30,11" fill="#111"/>
              </g>
            );
          }
          if(level===2){ // Pen
            return (
              <g opacity={opacity} transform={`translate(${x-14*s},${y-6*s}) scale(${s})`}>
                <rect x={0} y={2} width={28} height={8} rx={4} fill="#2563eb" stroke="#1e40af"/>
                <rect x={24} y={2} width={6} height={8} rx={1} fill="#93c5fd" stroke="#1e40af"/>
              </g>
            );
          }
          // Marker
          return (
            <g opacity={opacity} transform={`translate(${x-16*s},${y-8*s}) scale(${s})`}>
              <rect x={0} y={2} width={32} height={12} rx={4} fill="#111827" stroke="#334155"/>
              <rect x={2} y={4} width={8} height={8} rx={2} fill="#ef4444" />
            </g>
          );
        }
        if(kind === TOWER_TYPES.ERASER){
          if(level===1){
            return (
              <g opacity={opacity} transform={`translate(${x-14*s},${y-10*s}) scale(${s})`}>
                <rect x={0} y={0} width={28} height={20} rx={6} fill="#fecdd3" stroke="#fb7185"/>
                <rect x={10} y={0} width={18} height={20} rx={6} fill="#fdf2f8" stroke="#f472b6"/>
              </g>
            );
          }
          if(level===2){
            return (
              <g opacity={opacity} transform={`translate(${x-18*s},${y-10*s}) scale(${s})`}>
                <rect x={0} y={2} width={36} height={16} rx={4} fill="#0ea5e9" stroke="#0369a1"/>
                <rect x={2} y={14} width={32} height={4} rx={2} fill="#1f2937"/>
              </g>
            );
          }
          return (
            <g opacity={opacity} transform={`translate(${x-16*s},${y-10*s}) scale(${s})`}>
              <rect x={0} y={0} width={32} height={20} rx={6} fill="#fde68a" stroke="#f59e0b"/>
              <circle cx={6} cy={6} r={1.5} fill="#f59e0b"/><circle cx={12} cy={12} r={1.5} fill="#f59e0b"/>
              <circle cx={20} cy={8} r={1.5} fill="#f59e0b"/><circle cx={26} cy={14} r={1.5} fill="#f59e0b"/>
            </g>
          );
        }
        if(kind === TOWER_TYPES.CALCULATOR){
          const shell = (w,h,screenColor='#d1fae5') => (
            <g>
              <rect x={0} y={0} width={w} height={h} rx={4} fill="#e5e7eb" stroke="#9ca3af"/>
              <rect x={4} y={4} width={w-8} height={10} rx={2} fill={screenColor} stroke="#10b981"/>
              {[...Array(8)].map((_,i)=>{const cols=4, r=Math.floor(i/cols), c=i%cols; return (
                <rect key={i} x={4+c*6} y={18+r*6} width="5" height="5" rx="1" fill="#fff" stroke="#9ca3af"/>
              )})}
            </g>
          );
          if(level===1){
            return (<g opacity={opacity} transform={`translate(${x-14*s},${y-22*s}) scale(${s})`}>{shell(28,40,'#d1fae5')}</g>);
          }
          if(level===2){
            return (<g opacity={opacity} transform={`translate(${x-16*s},${y-24*s}) scale(${s})`}>{shell(32,44,'#bbf7d0')}</g>);
          }
          return (<g opacity={opacity} transform={`translate(${x-18*s},${y-26*s}) scale(${s})`}>{shell(36,48,'#a7f3d0')}</g>);
        }
        // Ruler → Yardstick → Tape Measure
        const tickCount = level===1?8 : level===2?10 : 10;
        return (
          <g opacity={opacity} transform={`translate(${x-(level===3?10:18)*s},${y-6*s}) scale(${s})`}>
            {level<3 ? (
              <g>
                <rect x={0} y={0} width={level===2?40:36} height={12} rx={2} fill="#fde68a" stroke="#f59e0b"/>
                {[...Array(tickCount)].map((_,i)=><line key={i} x1={4+i*4} y1={2} x2={4+i*4} y2={i%2?6:10} stroke="#b45309" strokeWidth="1"/>)}
              </g>
            ):(
              <g>
                <rect x={8} y={0} width={28} height={12} rx={2} fill="#fde68a" stroke="#f59e0b"/>
                <rect x={0} y={0} width={10} height={12} rx={2} fill="#93c5fd" stroke="#1d4ed8"/>
                {[...Array(7)].map((_,i)=><line key={i} x1={12+i*4} y1={2} x2={12+i*4} y2={i%2?6:10} stroke="#b45309" strokeWidth="1"/>)}
              </g>
            )}
          </g>
        );
      }

      // upgrade confirm modal
      function UpgradeModal({ open, tower, onCancel, onConfirm }){
        if(!open || !tower) return null;
        const curr = baseTowerStats(tower.kind, tower.level);
        const nextLevel = clamp(tower.level+1,1,3);
        const next = baseTowerStats(tower.kind, nextLevel);
        const cost = upgradeCost(tower.level);
        const delta = {
          range: Math.floor(next.range - curr.range),
          dmg: next.dmg - curr.dmg,
          rof: Math.max(0, curr.fireRate - next.fireRate)
        };
        return (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white w-[420px] rounded-2xl shadow-2xl p-4 border">
              <h3 className="text-lg font-bold">Upgrade {curr.name} → {next.name}</h3>
              <div className="mt-3 flex items-center gap-4">
                <svg width="80" height="60"><g transform="translate(40,30)"><TowerSprite kind={tower.kind} level={tower.level} x={0} y={0} scale={1.2}/></g></svg>
                <span className="text-2xl">→</span>
                <svg width="80" height="60"><g transform="translate(40,30)"><TowerSprite kind={tower.kind} level={nextLevel} x={0} y={0} scale={1.2}/></g></svg>
              </div>
              <div className="mt-3 text-sm">
                <div>Cost: <b>{cost}</b> Study Points</div>
                <ul className="mt-2 list-disc ml-5">
                  <li>Range: +{delta.range}</li>
                  <li>Damage: +{delta.dmg}</li>
                  <li>Faster rate of fire: −{delta.rof} ms</li>
                </ul>
              </div>
              <div className="mt-4 flex justify-end gap-2">
                <button className="px-3 py-2 rounded-lg bg-gray-200" onClick={onCancel}>Cancel</button>
                <button className="px-3 py-2 rounded-lg bg-emerald-600 text-white" onClick={onConfirm}>Confirm Upgrade</button>
              </div>
            </div>
          </div>
        );
      }

      // win / endless modal
      function WinModal({ open, onContinue }){
        if(!open) return null;
        return (
          <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
            <div className="bg-white w-[420px] rounded-2xl shadow-2xl p-5 border text-center">
              <h3 className="text-2xl font-extrabold">You Beat All 50 Waves! 🎉</h3>
              <p className="mt-2 text-gray-700">Want to keep going? Endless mode ramps difficulty every wave.</p>
              <button className="mt-4 px-4 py-2 rounded-xl bg-indigo-600 text-white hover:bg-indigo-700" onClick={onContinue}>
                Continue — Endless Mode
              </button>
            </div>
          </div>
        );
      }

      function App(){
        // Start with exactly enough to buy a Pencil
        const [coins,setCoins]=useState(20);
        const [lives,setLives]=useState(20);
        const [wave,setWave]=useState(1);
        const [inWave,setInWave]=useState(false);
        const [endlessBoost,setEndlessBoost]=useState(0); // grows after 50

        const [speed,setSpeed]=useState(1); // 1x, 2x, 3x

        const [towers,setTowers]=useState([]);
        const [enemies,setEnemies]=useState([]);
        const [projectiles,setProjectiles]=useState([]);

        const [selectedKind,setSelectedKind]=useState(null);
        const [drag,setDrag]=useState(null); // {kind,x,y,valid}
        const [upgradeOpen,setUpgradeOpen]=useState(false);
        const [upgradeTower,setUpgradeTower]=useState(null);
        const [showWin,setShowWin]=useState(false);

        const startedRef = useRef(false);

        // spawn waves
        useEffect(()=>{
          let timer;
          if(inWave){
            let i=0; const schedule=[];
            const countBase = 10 + wave*3;
            const count = Math.min(40, countBase);
            for(let k=0;k<count;k++){
              const r=Math.random(); let type=ENEMY_TYPES.HOMEWORK;
              if(wave>=2 && r>0.55)  type=ENEMY_TYPES.QUIZ;
              if(wave>=5 && r>0.78)  type=ENEMY_TYPES.TEST;
              if(wave % 6 === 0 && k >= count-2) type=ENEMY_TYPES.FINAL;
              schedule.push(type);
            }
            const interval = clamp(520 - wave*6, 260, 520) / speed;
            timer=setInterval(()=>{
              if(i>=schedule.length){ clearInterval(timer); setTimeout(()=>setInWave(false),1000); return; }
              const type=schedule[i++]; const st=enemyStats(type,wave,endlessBoost);
              setEnemies(prev=>[...prev,{id:crypto.randomUUID(), t:0, hp:st.hp, type}]);
            }, interval);
          }
          return ()=>clearInterval(timer);
        },[inWave,wave,speed,endlessBoost]);

        // game loop
        useEffect(()=>{
          let last=performance.now(), raf;
          const step=(now)=>{
            const dt=(now-last)/1000; last=now;

            // enemy motion
            setEnemies(prev=>{
              const out=[];
              for(const e of prev){
                const st=enemyStats(e.type,wave,endlessBoost);
                const tNext=e.t + st.speed*dt*0.12*speed;
                if(tNext>=1) setLives(L=>Math.max(0, L-(e.type===ENEMY_TYPES.FINAL?5:1)));
                else out.push({...e,t:tNext});
              }
              return out;
            });

            // towers fire
            setTowers(prev=>{
              const nowMs=performance.now();
              const ens=enemies.map(e=>({...e,pos:pointAtT(PATH,e.t)}));
              const newP=[];
              const upd=prev.map(tw=>{
                const st=baseTowerStats(tw.kind,tw.level);
                const adjustedRate = Math.max(50, st.fireRate / speed);
                if(!tw.lastShot || nowMs - tw.lastShot > adjustedRate){
                  let target=null, maxT=-1;
                  for(const e of ens){
                    const pos=e.pos;
                    if(distance({x:tw.x,y:tw.y},pos)<=st.range){
                      if(e.t>maxT){ maxT=e.t; target=e; }
                    }
                  }
                  if(target){
                    const ang=Math.atan2(target.pos.y-tw.y, target.pos.x-tw.x);
                    const projSpeed = 320 * speed;
                    newP.push({id:crypto.randomUUID(), x:tw.x,y:tw.y, vx:Math.cos(ang)*projSpeed, vy:Math.sin(ang)*projSpeed, dmg:st.dmg, pierce:st.pierce||0, chain:st.chain||0});
                    return {...tw, lastShot:nowMs};
                  }
                }
                return tw;
              });
              if(newP.length) setProjectiles(p=>[...p,...newP]);
              return upd;
            });

            // projectiles
            setProjectiles(prev=>{
              const out=[]; const ens=enemies.map(e=>({...e,pos:pointAtT(PATH,e.t)}));
              for(const p of prev){
                const nx=p.x+p.vx*dt, ny=p.y+p.vy*dt; let hit=-1;
                for(let i=0;i<ens.length;i++){ if(distance({x:nx,y:ny},ens[i].pos)<14){ hit=i; break; } }
                if(hit>=0){
                  const eHit=ens[hit];
                  setEnemies(arr=>{
                    const copy=[...arr]; const idx=copy.findIndex(x=>x.id===eHit.id);
                    if(idx>=0){
                      const type=copy[idx].type, newHp=copy[idx].hp - p.dmg;
                      if(newHp<=0){ const st=enemyStats(type,wave,endlessBoost); copy.splice(idx,1); setCoins(c=>c+st.reward); }
                      else copy[idx]={...copy[idx], hp:newHp};
                    }
                    return copy;
                  });
                  if(p.pierce&&p.pierce>0) out.push({...p,x:nx,y:ny,pierce:p.pierce-1});
                  else if(p.chain&&p.chain>0){
                    const others=ens.filter(e=>e.id!==eHit.id); let best=null,bestD=1e9;
                    for(const e of others){ const d=distance({x:nx,y:ny},e.pos); if(d<80&&d<bestD){ best=e; bestD=d; } }
                    if(best){ const ang=Math.atan2(best.pos.y-ny, best.pos.x-nx); out.push({...p,x:nx,y:ny, vx=Math.cos(ang)*320*speed, vy=Math.sin(ang)*320*speed, chain:p.chain-1}); }
                  }
                } else if(nx<-20||ny<-20||nx>MAP_W+20||ny>MAP_H+20){
                  // offscreen
                } else out.push({...p,x:nx,y:ny});
              }
              return out;
            });

            raf=requestAnimationFrame(step);
          };
          raf=requestAnimationFrame(step);
          return ()=>cancelAnimationFrame(raf);
        },[enemies,wave,speed,endlessBoost]);

        // wave advance & win → endless (only if you actually started a wave)
        useEffect(()=>{
          if(!inWave && enemies.length===0 && startedRef.current){
            if(wave < TOTAL_WAVES){
              setWave(w=>w+1);
              setCoins(c=>c+26);
              startedRef.current = false;
            } else if(wave === TOTAL_WAVES){
              setShowWin(true);
              startedRef.current = false;
            }
          }
        },[inWave,enemies.length,wave]);

        useEffect(()=>{ if(lives<=0) alert("Class dismissed! The Exams reached your desk. Reload to try again."); },[lives]);

        function beginWave(){
          if(!inWave){
            setInWave(true);
            startedRef.current = true;
          }
        }
        function cycleSpeed(){ setSpeed(s=> s===1 ? 2 : s===2 ? 3 : 1); }

        // drag & place
        function canPlaceAt(kind, x, y){
          if (x<24 || x>MAP_W-24 || y<24 || y>MAP_H-24) return false;
          const nearPath = PATH.some((_,i)=>{
            if(i===PATH.length-1) return false;
            const A=PATH[i], B=PATH[i+1]; const ABx=B.x-A.x, ABy=B.y-A.y;
            const t=clamp(((x-A.x)*ABx + (y-A.y)*ABy)/(ABx*ABx + ABy*ABy),0,1);
            const proj={x:A.x+ABx*t, y:A.y+ABy*t};
            return distance({x,y},proj) < 40;
          });
          if(nearPath) return false;
          for(const t of towers){ if(distance({x,y},{x:t.x,y:t.y})<34) return false; }
          return true;
        }

        function startDrag(kind){ setSelectedKind(kind); setDrag({ kind, x: MAP_W/2, y: MAP_H/2, valid:false }); }
        function onBoardMove(e){
          if(!drag) return;
          const rect=e.currentTarget.getBoundingClientRect();
          const x=e.clientX - rect.left, y=e.clientY - rect.top;
          setDrag(d=> d ? ({...d, x, y, valid: canPlaceAt(d.kind,x,y) && coins >= BASE_COST[d.kind] }) : d);
        }
        function onBoardClick(){
          if(!drag) return;
          const {kind,x,y,valid}=drag; if(!valid) return;
          const cost=BASE_COST[kind]; if(coins<cost) return;
          setCoins(c=>c-cost);
          setTowers(arr=>[...arr,{id:crypto.randomUUID(), x,y, kind, level:1, lastShot:0}]);
          setDrag(null); setSelectedKind(null);
        }
        function cancelDrag(){ if(drag){ setDrag(null); setSelectedKind(null); } }

        // upgrades (confirm first)
        function requestUpgrade(tower){
          if(tower.level>=3) return;
          setUpgradeTower(tower);
          setUpgradeOpen(true);
        }
        function confirmUpgrade(){
          const t = upgradeTower;
          if(!t){ setUpgradeOpen(false); return; }
          const cost = upgradeCost(t.level);
          if(coins < cost){ setUpgradeOpen(false); return; }
          setCoins(c=>c-cost);
          setTowers(arr=>arr.map(x=> x.id===t.id ? {...x, level: clamp(x.level+1,1,3)} : x));
          setUpgradeOpen(false);
          setUpgradeTower(null);
        }

        function continueEndless(){
          setShowWin(false);
          setWave(w=>w+1);              // wave 51, etc.
          setEndlessBoost(b=> b + 0.08);
          startedRef.current = true;
          setInWave(true);
        }

        const pathPolyline=useMemo(()=> PATH.map(p=>`${p.x},${p.y}`).join(" "), []);

        return (
          <div className="w-full min-h-screen text-gray-900 p-4">
            <div className="max-w-[1200px] mx-auto">
              <h1 className="text-2xl font-extrabold tracking-tight">📚 Classroom Defense — Math Game v2</h1>
              <p className="text-sm text-gray-700">Drag to place. Click a tower to upgrade (with confirmation). Shooting from the start enabled.</p>

              <div className="mt-3 flex items-center gap-3 flex-wrap">
                <div className="px-3 py-2 rounded-xl bg-white shadow border">💰 Study Points: <b>{formatCoins(coins)}</b></div>
                <div className="px-3 py-2 rounded-xl bg-white shadow border">❤️ Lives: <b>{lives}</b></div>
                <div className="px-3 py-2 rounded-xl bg-white shadow border">📈 Wave: <b>{wave}{wave>TOTAL_WAVES?" (Endless)":""}</b></div>

                <button className={`px-4 py-2 rounded-xl shadow text-white ${inWave?"bg-gray-400":"bg-emerald-600 hover:bg-emerald-700"}`}
                        onClick={beginWave} disabled={inWave}>
                  {inWave?"Wave Running…":"Start Wave"}
                </button>

                <button className="px-4 py-2 rounded-xl shadow bg-indigo-600 hover:bg-indigo-700 text-white"
                        onClick={cycleSpeed}>
                  ⏩ Speed: {speed}x
                </button>
              </div>

              {/* Build bar */}
              <div className="mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2">
                {Object.values(TOWER_TYPES).map(kind=>(
                  <button key={kind} onClick={()=>startDrag(kind)}
                          className={`border rounded-xl p-3 bg-white shadow hover:shadow-md transition ${selectedKind===kind?"ring-2 ring-blue-500":""}`}>
                    <div className="flex items-center gap-2">
                      <svg width="28" height="28"><g transform="translate(14,14)"><TowerSprite kind={kind} level={1} x={0} y={0} scale={0.9}/></g></svg>
                      <div className="font-bold">{baseTowerStats(kind,1).name}</div>
                    </div>
                    <div className="text-xs text-gray-600 mt-1">Cost: {BASE_COST[kind]}</div>
                    <div className="text-xs text-gray-500">
                      {(()=>{const s=baseTowerStats(kind,1); return `Rng ${Math.floor(s.range)} / Dmg ${s.dmg} / ROF ${Math.max(200,s.fireRate)}ms`})()}
                    </div>
                    <div className="text-[10px] text-emerald-700 mt-1">Drag onto board to place</div>
                  </button>
                ))}
              </div>

              {/* Board */}
              <div className="mt-4 relative rounded-3xl border shadow overflow-hidden">
                <svg width={MAP_W} height={MAP_H}
                     onMouseMove={onBoardMove} onClick={onBoardClick} onMouseLeave={cancelDrag}
                     style={{cursor: drag ? (drag.valid ? 'copy' : 'not-allowed') : 'crosshair'}}
                     className="block">
                  {/* Floor tiles */}
                  <defs>
                    <pattern id="tiles" width="24" height="24" patternUnits="userSpaceOnUse">
                      <rect width="24" height="24" fill="#fafafa"/>
                      <path d="M 0 24 L 24 0" stroke="#f1f5f9" strokeWidth="1"/>
                    </pattern>
                  </defs>
                  <rect x={0} y={0} width={MAP_W} height={MAP_H} fill="url(#tiles)"/>

                  {/* decor */}
                  <ClassroomDecor/>

                  {/* Hallway path */}
                  <polyline points={pathPolyline} fill="none" stroke="#cbd5e1" strokeWidth="30" strokeLinejoin="round" strokeLinecap="round"/>
                  <polyline points={pathPolyline} fill="none" stroke="#64748b" strokeWidth="6" strokeLinejoin="round" strokeLinecap="round"/>

                  {/* Base / Desk */}
                  <g>
                    <rect x={820} y={330} width={64} height={64} rx={12} fill="#fff7ed" stroke="#fb923c" strokeWidth="3"/>
                    <text x={852} y={364} textAnchor="middle" fontSize="12">Desk</text>
                  </g>

                  {/* Towers */}
                  {towers.map(t=>(
                    <g key={t.id} onClick={(e)=>{ e.stopPropagation(); requestUpgrade(t); }} className="cursor-pointer">
                      <TowerSprite kind={t.kind} level={t.level} x={t.x} y={t.y}/>
                      {[...Array(t.level)].map((_,i)=> <circle key={i} cx={t.x-10+i*6} cy={t.y+16} r="2" fill="#334155" />)}
                    </g>
                  ))}

                  {/* Enemies */}
                  {enemies.map(e=>{
                    const pos=pointAtT(PATH,e.t);
                    let emoji="📄"; if(e.type===ENEMY_TYPES.QUIZ) emoji="❓"; if(e.type===ENEMY_TYPES.TEST) emoji="📘"; if(e.type===ENEMY_TYPES.FINAL) emoji="📚";
                    return (
                      <g key={e.id}>
                        <text x={pos.x} y={pos.y} fontSize="20" textAnchor="middle" dominantBaseline="middle">{emoji}</text>
                        <rect x={pos.x-16} y={pos.y-24} width="32" height="4" fill="#fee2e2" rx="2"/>
                        <rect x={pos.x-16} y={pos.y-24} width={clamp((e.hp/enemyStats(e.type,wave,endlessBoost).hp)*32,0,32)} height="4" fill="#ef4444" rx="2"/>
                      </g>
                    );
                  })}

                  {/* Projectiles */}
                  {projectiles.map(p=> (<circle key={p.id} cx={p.x} cy={p.y} r="3" fill="#111827" />))}

                  {/* Drag ghost & placement ring */}
                  {drag && (
                    <g pointerEvents="none">
                      <circle cx={drag.x} cy={drag.y} r={baseTowerStats(drag.kind,1).range}
                              fill="none" stroke={drag.valid?"#22c55e":"#ef4444"}
                              strokeDasharray="6 6" strokeWidth="2" opacity="0.7"/>
                      <TowerSprite kind={drag.kind} level={1} x={drag.x} y={drag.y} opacity={0.6}/>
                      <circle cx={drag.x} cy={drag.y} r="4" fill={drag.valid ? "#22c55e" : "#ef4444"} />
                    </g>
                  )}
                </svg>
              </div>

              <div className="mt-3 text-xs text-gray-600">
                Tip: Green = valid placement, red = blocked. Use ⏩ to cycle 1×/2×/3×.
              </div>
            </div>

            <UpgradeModal
              open={upgradeOpen}
              tower={upgradeTower}
              onCancel={()=>{ setUpgradeOpen(false); setUpgradeTower(null); }}
              onConfirm={confirmUpgrade}
            />
            <WinModal
              open={showWin}
              onContinue={()=>{
                setShowWin(false);
                setWave(w=>w+1);
                setEndlessBoost(b=> b + 0.08);
                startedRef.current = true;
                setInWave(true);
              }}
            />
          </div>
        );
      }

      // Mount with a guard so any unexpected error shows in the overlay
      try {
        ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
      } catch (err) {
        const box=document.createElement('div'); box.className='errbox';
        box.innerHTML='<b>Render error:</b><pre>'+String(err && err.message || err)+'</pre>';
        document.body.appendChild(box);
      }
    </script>
  </body>
</html>
