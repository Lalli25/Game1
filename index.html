<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Classroom Defense ‚Äî Math Game v2 (No-Framework)</title>
<style>
  :root { --bg:#eef2ff; --card:#ffffff; --ink:#111827; --muted:#64748b; --border:#cbd5e1; --accent:#4f46e5; --accent2:#10b981; --warn:#ef4444; --ok:#22c55e; }
  html,body{height:100%} body{margin:0;font:14px/1.4 system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#111}
  .wrap{max-width:1200px;margin:0 auto;padding:16px}
  h1{margin:0 0 4px;font-size:22px;font-weight:800}
  .bar{display:flex;gap:8px;flex-wrap:wrap;margin:8px 0}
  .pill{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:8px 12px;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .btn{cursor:pointer;border:none;border-radius:12px;padding:8px 14px;color:#fff;box-shadow:0 1px 2px rgba(0,0,0,.12)}
  .btn.green{background:#059669} .btn.green:disabled{background:#9ca3af;cursor:not-allowed}
  .btn.indigo{background:#4f46e5}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
  @media(min-width:640px){.grid{grid-template-columns:repeat(4,minmax(0,1fr))}}
  .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:10px;box-shadow:0 1px 2px rgba(0,0,0,.06);cursor:pointer}
  .build-name{font-weight:700}
  .hint{font-size:11px;color:#065f46;margin-top:4px}
  .board{margin-top:12px;border:1px solid var(--border);border-radius:16px;box-shadow:0 2px 6px rgba(0,0,0,.06);overflow:hidden;position:relative}
  svg{display:block}

  /* modal */
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;z-index:50}
  .modal{background:#fff;width:420px;max-width:calc(100% - 24px);border-radius:16px;border:1px solid var(--border);box-shadow:0 10px 30px rgba(0,0,0,.2);padding:16px}
  .modal h3{margin:0 0 8px;font-size:18px;font-weight:800}
  .modal .row{display:flex;gap:12px;align-items:center}
  .modal .actions{margin-top:12px;display:flex;gap:8px;justify-content:flex-end}
  .btn.gray{background:#e5e7eb;color:#111}
  .btn.em{background:#059669}
  .small{font-size:12px;color:#374151}

  /* error box (if anything ever throws) */
  .err{position:fixed;left:12px;right:12px;bottom:12px;background:#fee2e2;border:1px solid #ef4444;color:#7f1d1d;border-radius:12px;padding:10px;z-index:999}
  .err pre{white-space:pre-wrap;margin:6px 0 0}
</style>
</head>
<body>
<div class="wrap">
  <h1>üìö Classroom Defense ‚Äî Math Game v2</h1>
  <p class="small">Drag to place. Click a tower to upgrade (with confirmation). Shooting from the start is enabled.</p>

  <div class="bar">
    <div class="pill">üí∞ Study Points: <b id="coins">0</b></div>
    <div class="pill">‚ù§Ô∏è Lives: <b id="lives">0</b></div>
    <div class="pill">üìà Wave: <b id="wave">1</b></div>
    <button id="startBtn" class="btn green">Start Wave</button>
    <button id="speedBtn" class="btn indigo">‚è© Speed: <span id="speedTxt">1x</span></button>
  </div>

  <!-- Build bar -->
  <div class="grid" id="buildBar"></div>

  <!-- Game board -->
  <div class="board">
    <svg id="game" width="900" height="540"></svg>
  </div>

  <div class="small" style="margin-top:6px">Tip: Green = valid placement, red = blocked. Use ‚è© to cycle 1√ó/2√ó/3√ó.</div>
</div>

<!-- Upgrade modal -->
<div class="modal-backdrop" id="upgradeBackdrop">
  <div class="modal">
    <h3 id="upTitle">Upgrade</h3>
    <div class="row" style="margin:6px 0 8px">
      <svg width="90" height="60"><g transform="translate(45,30)" id="upCurr"></g></svg>
      <div style="font-size:22px">‚Üí</div>
      <svg width="90" height="60"><g transform="translate(45,30)" id="upNext"></g></svg>
    </div>
    <div class="small" id="upDesc"></div>
    <div class="actions">
      <button class="btn gray" id="upCancel">Cancel</button>
      <button class="btn em" id="upConfirm">Confirm Upgrade</button>
    </div>
  </div>
</div>

<!-- Win modal -->
<div class="modal-backdrop" id="winBackdrop">
  <div class="modal" style="text-align:center">
    <h3>You Beat All 50 Waves! üéâ</h3>
    <p class="small">Want to keep going? Endless mode ramps difficulty every wave.</p>
    <div class="actions" style="justify-content:center">
      <button class="btn indigo" id="continueBtn">Continue ‚Äî Endless Mode</button>
    </div>
  </div>
</div>

<script>
'use strict';

// Minimal error overlay if something unexpected happens
function showErrBox(title, detail){
  const box=document.createElement('div'); box.className='err';
  box.innerHTML='<b>'+title+'</b><pre>'+detail+'</pre>';
  document.body.appendChild(box);
}
window.addEventListener('unhandledrejection', e=>showErrBox('Promise error', String(e.reason)));
window.addEventListener('error', e=>showErrBox('Script error', (e.error && (e.error.stack||e.error.message)) || (e.message||'unknown')));

// randomUUID polyfill
if(!window.crypto) window.crypto = {};
if(typeof window.crypto.randomUUID!=='function'){
  window.crypto.randomUUID = function(){
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,c=>{
      const r=Math.random()*16|0, v=c==='x'?r:(r&0x3|0x8); return v.toString(16);
    });
  };
}

// ====== GAME STATE ======
const MAP_W=900, MAP_H=540;
const PATH=[{x:40,y:100},{x:220,y:100},{x:220,y:60},{x:360,y:60},{x:360,y:180},{x:520,y:180},{x:520,y:320},{x:320,y:320},{x:320,y:420},{x:640,y:420},{x:640,y:280},{x:800,y:280},{x:860,y:360}];
const TOTAL_WAVES=50;

const TOWER={PENCIL:'PENCIL',ERASER:'ERASER',CALCULATOR:'CALC',RULER:'RULER'};
const ENEMY={HOMEWORK:'HW',QUIZ:'QZ',TEST:'TS',FINAL:'FN'};

const BASE_COST={PENCIL:20,ERASER:35,CALC:45,RULER:60};
const upgradeCost = lvl => 40 + lvl*45;

function clamp(n,a,b){return Math.max(a,Math.min(b,n))}
function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}
function lerp(a,b,t){return a+(b-a)*t}
function pathLength(pts){let L=0;for(let i=0;i<pts.length-1;i++)L+=dist(pts[i],pts[i+1]);return L}
const PATH_LEN=pathLength(PATH);
function pointAtT(t){ // 0..1
  let target=t*PATH_LEN, acc=0;
  for(let i=0;i<PATH.length-1;i++){
    const A=PATH[i], B=PATH[i+1], seg=dist(A,B);
    if(acc+seg>=target){ const u=(target-acc)/seg; return {x:lerp(A.x,B.x,u),y:lerp(A.y,B.y,u)} }
    acc+=seg;
  }
  return PATH[PATH.length-1];
}

function enemyStats(type,wave,boost=0){
  const s=(1+wave*0.09)*(1+boost);
  if(type===ENEMY.HOMEWORK) return {hp:18*s, speed:0.055, reward:3};
  if(type===ENEMY.QUIZ)     return {hp:36*s, speed:0.043, reward:7};
  if(type===ENEMY.TEST)     return {hp:85*s, speed:0.034, reward:14};
  if(type===ENEMY.FINAL)    return {hp:320*s, speed:0.030, reward:45};
  return {hp:20,speed:0.04,reward:5};
}
function towerStats(kind,level=1){
  const L=clamp(level,1,3);
  if(kind===TOWER.PENCIL) return {range:115+10*L, dmg:5+2*L, fire:630-30*L, name:['Pencil','Pen','Marker'][L-1]};
  if(kind===TOWER.ERASER) return {range:135+12*L, dmg:12+4*L, fire:880-40*L, name:['Eraser','Board Eraser','Giant Sponge'][L-1]};
  if(kind===TOWER.CALCULATOR) return {range:150+14*L,dmg:8+1*L,fire:400-15*L,chain:2+(L-1),name:['Calculator','Sci Calc','Graphing Calc'][L-1]};
  if(kind===TOWER.RULER) return {range:190+22*L,dmg:10+3*L,fire:760-60*L,pierce:1+L,name:['Ruler','Yardstick','Tape Measure'][L-1]};
  return {range:100,dmg:5,fire:800,name:'?'};
}

// ====== DOM ======
const coinsEl=document.getElementById('coins');
const livesEl=document.getElementById('lives');
const waveEl=document.getElementById('wave');
const startBtn=document.getElementById('startBtn');
const speedBtn=document.getElementById('speedBtn');
const speedTxt=document.getElementById('speedTxt');
const buildBar=document.getElementById('buildBar');
const svg=document.getElementById('game');

const upBackdrop=document.getElementById('upgradeBackdrop');
const upTitle=document.getElementById('upTitle');
const upDesc=document.getElementById('upDesc');
const upCurr=document.getElementById('upCurr');
const upNext=document.getElementById('upNext');
const upCancel=document.getElementById('upCancel');
const upConfirm=document.getElementById('upConfirm');

const winBackdrop=document.getElementById('winBackdrop');
const continueBtn=document.getElementById('continueBtn');

// ====== SVG helpers ======
function svgEl(tag, attrs={}, parent){
  const el=document.createElementNS('http://www.w3.org/2000/svg', tag);
  for(const k in attrs){ el.setAttribute(k, attrs[k]); }
  if(parent) parent.appendChild(el);
  return el;
}

// Background & path
function drawBoardStatic(){
  svg.innerHTML='';
  // floor pattern
  const defs=svgEl('defs',{},svg);
  const pat=svgEl('pattern',{id:'tiles',width:24,height:24,patternUnits:'userSpaceOnUse'},defs);
  svgEl('rect',{width:24,height:24,fill:'#fafafa'},pat);
  svgEl('path',{d:'M 0 24 L 24 0',stroke:'#f1f5f9','stroke-width':1},pat);
  svgEl('rect',{x:0,y:0,width:MAP_W,height:MAP_H,fill:'url(#tiles)'},svg);

  // decor (lockers)
  for(let i=0;i<6;i++){
    svgEl('rect',{x:0,y:80+i*70,width:28,height:56,rx:4,fill:'#3b82f6',stroke:'#1d4ed8','stroke-width':1},svg);
  }
  // desks
  const desks=[{x:260,y:120},{x:420,y:120},{x:580,y:120},{x:260,y:260},{x:420,y:260},{x:580,y:260},{x:260,y:400},{x:420,y:400},{x:700,y:360}];
  desks.forEach(d=>{
    svgEl('rect',{x:d.x,y:d.y,width:70,height:40,rx:6,fill:'#f1f5f9',stroke:'#94a3b8'},svg);
    svgEl('circle',{cx:d.x+10,cy:d.y+36,r:3,fill:'#64748b'},svg);
  });
  // title board
  svgEl('rect',{x:40,y:10,width:300,height:36,rx:6,fill:'#083344',stroke:'#052e2b','stroke-width':2},svg);
  svgEl('text',{x:190,y:34,'text-anchor':'middle','font-size':16,fill:'#bbf7d0'},svg).textContent='Room 207 ‚Äî Geometry';

  // path
  const pts=PATH.map(p=>`${p.x},${p.y}`).join(' ');
  svgEl('polyline',{points:pts,fill:'none',stroke:'#cbd5e1','stroke-width':30,'stroke-linejoin':'round','stroke-linecap':'round'},svg);
  svgEl('polyline',{points:pts,fill:'none',stroke:'#64748b','stroke-width':6,'stroke-linejoin':'round','stroke-linecap':'round'},svg);

  // base desk
  svgEl('rect',{x:820,y:330,width:64,height:64,rx:12,fill:'#fff7ed',stroke:'#fb923c','stroke-width':3},svg);
  svgEl('text',{x:852,y:364,'text-anchor':'middle','font-size':12},svg).textContent='Desk';
}
drawBoardStatic();

// ====== Stateful entities ======
let coins=20, lives=20, wave=1, inWave=false, endlessBoost=0, speed=1;
let started=false;

let towers=[];   // {id,x,y,kind,level,lastShot}
let enemies=[];  // {id,t,type,hp}
let projs=[];    // {id,x,y,vx,vy,dmg,pierce,chain}

function syncUI(){
  coinsEl.textContent=Math.floor(coins);
  livesEl.textContent=lives;
  waveEl.textContent = wave + (wave>TOTAL_WAVES ? ' (Endless)' : '');
  speedTxt.textContent = speed+'x';
  startBtn.disabled = inWave;
  startBtn.textContent = inWave ? 'Wave Running‚Ä¶' : 'Start Wave';
}
syncUI();

// ====== Build bar ======
const BUILD_TYPES=[TOWER.PENCIL,TOWER.ERASER,TOWER.CALCULATOR,TOWER.RULER];
function typeName(t){ return towerStats(t,1).name; }
function makeBuildCard(kind){
  const card=document.createElement('div'); card.className='card';
  const row=document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px';
  const icon=document.createElementNS('http://www.w3.org/2000/svg','svg'); icon.setAttribute('width','28'); icon.setAttribute('height','28');
  const g=document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('transform','translate(14,14)');
  icon.appendChild(g);
  drawTowerSprite(g, kind, 1, 0,0,0.9,1);

  const name=document.createElement('div'); name.className='build-name'; name.textContent=typeName(kind);
  row.appendChild(icon); row.appendChild(name); card.appendChild(row);

  const cost=document.createElement('div'); cost.className='small'; cost.style.marginTop='4px'; cost.textContent='Cost: '+BASE_COST[kind];
  const stats=document.createElement('div'); stats.className='small'; stats.style.color='#6b7280';
  const s=towerStats(kind,1);
  stats.textContent=`Rng ${Math.floor(s.range)} / Dmg ${s.dmg} / ROF ${Math.max(200,s.fire)}ms`;
  const hint=document.createElement('div'); hint.className='hint'; hint.textContent='Drag onto board to place';
  card.appendChild(cost); card.appendChild(stats); card.appendChild(hint);

  // drag handling (simple: click to arm drag, move on board)
  card.addEventListener('mousedown', ()=> startDrag(kind));
  return card;
}
function renderBuildBar(){
  buildBar.innerHTML='';
  BUILD_TYPES.forEach(k=> buildBar.appendChild(makeBuildCard(k)));
}
renderBuildBar();

// ====== Drag & placement ======
let drag = null; // {kind,x,y,valid}
function canPlaceAt(kind,x,y){
  if(x<24||x>MAP_W-24||y<24||y>MAP_H-24) return false;
  // not too close to path
  for(let i=0;i<PATH.length-1;i++){
    const A=PATH[i],B=PATH[i+1], ABx=B.x-A.x, ABy=B.y-A.y;
    const t=clamp(((x-A.x)*ABx+(y-A.y)*ABy)/(ABx*ABx+ABy*ABy),0,1);
    const proj={x:A.x+ABx*t,y:A.y+ABy*t};
    if(dist({x,y},proj)<40) return false;
  }
  for(const t of towers){ if(dist({x,y},{x:t.x,y:t.y})<34) return false; }
  return true;
}
function startDrag(kind){ drag={kind,x:MAP_W/2,y:MAP_H/2,valid:false}; drawScene(); }
svg.addEventListener('mousemove', e=>{
  if(!drag) return;
  const rect=svg.getBoundingClientRect();
  const x=e.clientX-rect.left, y=e.clientY-rect.top;
  drag.x=x; drag.y=y; drag.valid = canPlaceAt(drag.kind,x,y) && coins>=BASE_COST[drag.kind];
  svg.style.cursor = drag.valid ? 'copy' : 'not-allowed';
  drawScene();
});
svg.addEventListener('mouseleave', ()=>{ if(drag){ drag=null; svg.style.cursor='crosshair'; drawScene(); }});
svg.addEventListener('click', ()=>{
  if(!drag) return;
  if(!drag.valid) return;
  const cost=BASE_COST[drag.kind]; if(coins<cost) return;
  coins-=cost;
  towers.push({id:crypto.randomUUID(),x:drag.x,y:drag.y,kind:drag.kind,level:1,lastShot:0});
  drag=null; svg.style.cursor='crosshair'; syncUI(); drawScene();
});

// ====== Upgrade modal logic ======
let pendingUpgrade=null; // tower object ref
function openUpgradeModal(t){
  if(t.level>=3) return;
  pendingUpgrade=t;
  const curr=towerStats(t.kind,t.level);
  const next=towerStats(t.kind, clamp(t.level+1,1,3));
  upTitle.textContent = `Upgrade ${curr.name} ‚Üí ${next.name}`;
  upDesc.innerHTML = `Cost: <b>${upgradeCost(t.level)}</b> Study Points
    <ul style="margin:6px 0 0 16px">
      <li>Range: +${Math.floor(next.range-curr.range)}</li>
      <li>Damage: +${next.dmg-curr.dmg}</li>
      <li>Faster rate of fire: ‚àí${Math.max(0,curr.fire-next.fire)} ms</li>
    </ul>`;
  upCurr.innerHTML=''; upNext.innerHTML='';
  drawTowerSprite(upCurr, t.kind, t.level, 0,0,1.2,1);
  drawTowerSprite(upNext, t.kind, clamp(t.level+1,1,3), 0,0,1.2,1);
  upBackdrop.style.display='flex';
}
upCancel.onclick=()=>{ upBackdrop.style.display='none'; pendingUpgrade=null; };
upConfirm.onclick=()=>{
  if(!pendingUpgrade) return;
  const t=pendingUpgrade;
  const cost=upgradeCost(t.level);
  if(coins>=cost){
    coins-=cost;
    t.level=clamp(t.level+1,1,3);
    syncUI(); drawScene();
  }
  upBackdrop.style.display='none';
  pendingUpgrade=null;
};

// ====== Win modal ======
continueBtn.onclick=()=>{
  winBackdrop.style.display='none';
  wave+=1; endlessBoost+=0.08; started=true; inWave=true; spawnWave();
  syncUI();
};

// ====== Tower sprite drawing (SVG) ======
function drawTowerSprite(g, kind, level, cx, cy, scale=1, opacity=1){
  function set(o){ for(const k in o) el.setAttribute(k,o[k]); }
  function rect(x,y,w,h,rx,fill,stroke,sw){
    const el=svgEl('rect',{x:x,y:y,width:w,height:h,rx:rx||0,fill,stroke:stroke||'none','stroke-width':sw||1},g);
    return el;
  }
  function line(x1,y1,x2,y2,stroke,sw){
    return svgEl('line',{x1,y1,x2,y2,stroke,'stroke-width':sw||1},g);
  }
  const base = document.createElementNS('http://www.w3.org/2000/svg','g');
  base.setAttribute('opacity',opacity);
  base.setAttribute('transform',`translate(${cx},${cy}) scale(${scale})`);
  g.appendChild(base);

  if(kind===TOWER.PENCIL){
    if(level===1){
      rect(-10,-6,20,12,2,'#f59e0b','#92400e',1.2);
      const tip=svgEl('polygon',{points:'10,-6 18,0 10,6',fill:'#fde68a',stroke:'#92400e'},base);
      const lead=svgEl('polygon',{points:'18,0 20,0 18,-1',fill:'#111'},base);
      return;
    }
    if(level===2){
      rect(-14,-4,28,8,4,'#2563eb','#1e40af',1.2);
      rect(10,-4,8,8,1,'#93c5fd','#1e40af',1);
      return;
    }
    rect(-16,-6,32,12,4,'#111827','#334155',1.2);
    rect(-14,-4,8,8,2,'#ef4444','none',1);
    return;
  }
  if(kind===TOWER.ERASER){
    if(level===1){
      rect(-14,-10,28,20,6,'#fecdd3','#fb7185',1.2);
      rect(-4,-10,18,20,6,'#fdf2f8','#f472b6',1.2);
      return;
    }
    if(level===2){
      rect(-18,-8,36,16,4,'#0ea5e9','#0369a1',1.2);
      rect(-16,6,32,4,2,'#1f2937','none',1);
      return;
    }
    rect(-16,-10,32,20,6,'#fde68a','#f59e0b',1.2);
    ['-10,-6','-4,2','4,-2','10,4'].forEach(p=>{
      const [x,y]=p.split(',').map(Number); svgEl('circle',{cx:x,cy:y,r:1.5,fill:'#f59e0b'},base);
    });
    return;
  }
  if(kind===TOWER.CALCULATOR){
    function shell(w,h,screen){ rect(-w/2,-h/2,w,h,4,'#e5e7eb','#9ca3af',1.2);
      rect(-w/2+4,-h/2+4,w-8,10,2,screen,'#10b981',1);
      for(let i=0;i<8;i++){ const r=(i/4)|0, c=i%4; rect(-w/2+4+c*6,-h/2+18+r*6,5,5,1,'#fff','#9ca3af',1); }
    }
    if(level===1){ shell(28,40,'#d1fae5'); return; }
    if(level===2){ shell(32,44,'#bbf7d0'); return; }
    shell(36,48,'#a7f3d0'); return;
  }
  // RULER / YARDSTICK / TAPE
  const isTape = (level===3);
  if(!isTape){
    rect(-18,-6, level===2?40:36,12,2,'#fde68a','#f59e0b',1.2);
    const ticks=level===1?8:10;
    for(let i=0;i<ticks;i++) line(-14+i*4,-4,-14+i*4, i%2?0:4,'#b45309',1);
  }else{
    rect(-10,-6,10,12,2,'#93c5fd','#1d4ed8',1.2);
    rect( -2,-6,28,12,2,'#fde68a','#f59e0b',1.2);
    for(let i=0;i<7;i++) line(2+i*4,-4,2+i*4, i%2?0:4,'#b45309',1);
  }
}

// ====== Scene drawing (dynamic layers) ======
let towersLayer, enemiesLayer, projsLayer, dragLayer;
function ensureLayers(){
  towersLayer = svgEl('g',{},svg);
  enemiesLayer = svgEl('g',{},svg);
  projsLayer = svgEl('g',{},svg);
  dragLayer = svgEl('g',{'pointer-events':'none'},svg);
}
ensureLayers();

function drawScene(){
  // reset dynamic layers
  [towersLayer,enemiesLayer,projsLayer,dragLayer].forEach(l=>l.remove());
  ensureLayers();

  // towers
  for(const t of towers){
    const g=svgEl('g',{},towersLayer);
    g.addEventListener('click', ev=>{ ev.stopPropagation(); openUpgradeModal(t); });
    drawTowerSprite(g, t.kind, t.level, t.x, t.y, 1, 1);
    // tiny pips for level
    for(let i=0;i<t.level;i++) svgEl('circle',{cx:t.x-10+i*6, cy:t.y+16, r:2, fill:'#334155'},towersLayer);
  }

  // enemies
  for(const e of enemies){
    const pos=pointAtT(e.t);
    const emoji = e.type===ENEMY.QUIZ?'‚ùì':(e.type===ENEMY.TEST?'üìò':(e.type===ENEMY.FINAL?'üìö':'üìÑ'));
    const tx=svgEl('text',{x:pos.x,y:pos.y,'font-size':20,'text-anchor':'middle','dominant-baseline':'middle'},enemiesLayer);
    tx.textContent=emoji;
    const st=enemyStats(e.type,wave,endlessBoost);
    svgEl('rect',{x:pos.x-16,y:pos.y-24,width:32,height:4,fill:'#fee2e2',rx:2},enemiesLayer);
    svgEl('rect',{x:pos.x-16,y:pos.y-24,width:clamp((e.hp/st.hp)*32,0,32),height:4,fill:'#ef4444',rx:2},enemiesLayer);
  }

  // projectiles
  for(const p of projs) svgEl('circle',{cx:p.x,cy:p.y,r:3,fill:'#111827'},projsLayer);

  // drag overlay
  if(drag){
    const r=towerStats(drag.kind,1).range;
    svgEl('circle',{cx:drag.x,cy:drag.y,r:r,fill:'none',stroke:drag.valid?'#22c55e':'#ef4444','stroke-dasharray':'6 6','stroke-width':2,opacity:.7},dragLayer);
    const ghost=svgEl('g',{'opacity':.6},dragLayer);
    drawTowerSprite(ghost, drag.kind, 1, drag.x, drag.y, 1, .6);
    svgEl('circle',{cx:drag.x,cy:drag.y,r:4,fill:drag.valid?'#22c55e':'#ef4444'},dragLayer);
  }
}
drawScene();

// ====== Combat loop ======
let lastTime=performance.now();
function loop(now){
  const dt=(now-lastTime)/1000; lastTime=now;

  // move enemies
  const outE=[];
  for(const e of enemies){
    const st=enemyStats(e.type,wave,endlessBoost);
    const tNext=e.t + st.speed*dt*0.12*speed;
    if(tNext>=1){
      lives -= (e.type===ENEMY.FINAL?5:1);
      if(lives<=0){ alert('Class dismissed! The Exams reached your desk. Reload to try again.'); lives=0; }
    } else outE.push({...e,t:tNext});
  }
  enemies=outE;

  // towers fire
  const ens = enemies.map(e=>({e, pos: pointAtT(e.t)}));
  const nowMs=performance.now();
  const newP=[];
  for(const t of towers){
    const st=towerStats(t.kind,t.level);
    const rof=Math.max(50, st.fire/speed);
    if(!t.lastShot || nowMs - t.lastShot > rof){
      let target=null, bestT=-1;
      for(const {e,pos} of ens){
        if(dist({x:t.x,y:t.y},pos)<=st.range && e.t>bestT){ bestT=e.t; target={e,pos}; }
      }
      if(target){
        const ang=Math.atan2(target.pos.y-t.y, target.pos.x-t.x);
        const v=320*speed;
        newP.push({id:crypto.randomUUID(),x:t.x,y:t.y,vx:Math.cos(ang)*v,vy:Math.sin(ang)*v,dmg:st.dmg,pierce:st.pierce||0,chain:st.chain||0});
        t.lastShot=nowMs;
      }
    }
  }
  if(newP.length) projs.push(...newP);

  // move projectiles & apply damage
  const outP=[];
  for(const p of projs){
    const nx=p.x+p.vx*dt, ny=p.y+p.vy*dt;
    // collision
    let hitIndex=-1, hitPos=null, ensNow=enemies.map(e=>({e,pos:pointAtT(e.t)}));
    for(let i=0;i<ensNow.length;i++){
      if(dist({x:nx,y:ny},ensNow[i].pos)<14){ hitIndex=i; hitPos=ensNow[i].pos; break; }
    }
    if(hitIndex>=0){
      const e=enemies[hitIndex];
      e.hp-=p.dmg;
      if(e.hp<=0){
        const st=enemyStats(e.type,wave,endlessBoost);
        enemies.splice(hitIndex,1);
        coins+=st.reward;
      }
      if(p.pierce && p.pierce>0){
        outP.push({...p,x:nx,y:ny,pierce:p.pierce-1});
      }else if(p.chain && p.chain>0){
        // retarget nearest within 80
        let best=null, bestD=1e9;
        ensNow=enemies.map(e=>({e,pos:pointAtT(e.t)}));
        for(const cand of ensNow){
          const d=dist({x:nx,y:ny},cand.pos);
          if(d<80 && d<bestD){ best=cand; bestD=d; }
        }
        if(best){
          const ang=Math.atan2(best.pos.y-ny,best.pos.x-nx);
          outP.push({...p,x:nx,y:ny,vx:Math.cos(ang)*320*speed,vy:Math.sin(ang)*320*speed,chain:p.chain-1});
        }
      }
    } else if(nx<-20||ny<-20||nx>MAP_W+20||ny>MAP_H+20){
      // drop
    } else outP.push({...p,x:nx,y:ny});
  }
  projs=outP;

  // wave progress / win
  if(!inWave && enemies.length===0 && started){
    if(wave < TOTAL_WAVES){
      wave+=1; coins+=26; started=false;
    } else if(wave===TOTAL_WAVES){
      winBackdrop.style.display='flex'; started=false;
    }
  }

  syncUI();
  drawScene();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ====== Spawning ======
let spawnTimer=null;
function spawnWave(){
  if(spawnTimer) clearInterval(spawnTimer);
  let i=0; const schedule=[];
  const countBase = 10 + wave*3;
  const count = Math.min(40, countBase);
  for(let k=0;k<count;k++){
    const r=Math.random(); let type=ENEMY.HOMEWORK;
    if(wave>=2 && r>0.55) type=ENEMY.QUIZ;
    if(wave>=5 && r>0.78) type=ENEMY.TEST;
    if(wave % 6===0 && k>=count-2) type=ENEMY.FINAL;
    schedule.push(type);
  }
  const interval = clamp(520 - wave*6, 260, 520) / speed;
  inWave=true; syncUI();
  spawnTimer=setInterval(()=>{
    if(i>=schedule.length){ clearInterval(spawnTimer); spawnTimer=null; setTimeout(()=>{inWave=false;},1000); return; }
    const type=schedule[i++]; const st=enemyStats(type,wave,endlessBoost);
    enemies.push({id:crypto.randomUUID(), t:0, type, hp:st.hp});
  }, interval);
}

// ====== Controls ======
startBtn.onclick=function(){
  if(!inWave){ started=true; spawnWave(); }
};
speedBtn.onclick=function(){
  speed = speed===1 ? 2 : (speed===2 ? 3 : 1);
  // if spawning, recreate timer with new interval
  if(inWave){ inWave=false; if(spawnTimer){ clearInterval(spawnTimer); spawnTimer=null; } setTimeout(()=>{ inWave=true; spawnWave(); }, 0); }
  syncUI();
};

// click to upgrade
svg.addEventListener('mousedown', function(ev){
  // if clicking on tower (approx hit test)
  const rect=svg.getBoundingClientRect(); const x=ev.clientX-rect.left, y=ev.clientY-rect.top;
  for(const t of towers){
    if(dist({x,y},{x:t.x,y:t.y})<18){ openUpgradeModal(t); return; }
  }
});

// ====== Done ======
</script>
</body>
</html>
