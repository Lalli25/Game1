<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Classroom Defense — Math Game v2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>html,body{height:100%} body{background:#eef2ff}</style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState } = React;

      // --- constants ---
      const TOWER_TYPES = { PENCIL:"PENCIL", ERASER:"ERASER", CALCULATOR:"CALCULATOR", RULER:"RULER" };
      const ENEMY_TYPES = { HOMEWORK:"HOMEWORK", QUIZ:"QUIZ", TEST:"TEST", FINAL:"FINAL" };

      const MAP_W = 900, MAP_H = 540;
      const PATH = [
        { x: 40, y: 100 }, { x: 220, y: 100 }, { x: 220, y: 60 },  { x: 360, y: 60 },
        { x: 360, y: 180 }, { x: 520, y: 180 }, { x: 520, y: 320 }, { x: 320, y: 320 },
        { x: 320, y: 420 }, { x: 640, y: 420 }, { x: 640, y: 280 }, { x: 800, y: 280 },
        { x: 860, y: 360 }
      ];

      // helpers
      function lerp(a,b,t){return a+(b-a)*t}
      function distance(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy)}
      function clamp(n,lo,hi){return Math.max(lo, Math.min(hi,n))}
      function formatCoins(n){return Math.floor(n)}
      function pathLength(pts){let L=0; for(let i=0;i<pts.length-1;i++) L+=distance(pts[i],pts[i+1]); return L}
      const PATH_LENGTH = pathLength(PATH);
      function pointAtT(pts,t){
        let target=t*PATH_LENGTH, acc=0;
        for(let i=0;i<pts.length-1;i++){
          const a=pts[i], b=pts[i+1], seg=distance(a,b);
          if(acc+seg>=target){ const local=(target-acc)/seg; return {x: lerp(a.x,b.x,local), y: lerp(a.y,b.y,local)} }
          acc+=seg;
        }
        return pts[pts.length-1];
      }

      // balance
      function enemyStats(type,wave){
        const s = 1 + wave*0.06;
        switch(type){
          case ENEMY_TYPES.HOMEWORK: return { hp:14*s, speed:0.050, reward:4 };
          case ENEMY_TYPES.QUIZ:     return { hp:30*s, speed:0.040, reward:8 };
          case ENEMY_TYPES.TEST:     return { hp:70*s, speed:0.033, reward:16 };
          case ENEMY_TYPES.FINAL:    return { hp:260*s, speed:0.028, reward:50 };
          default:                   return { hp:20, speed:0.04, reward:5 };
        }
      }
      function baseTowerStats(kind, level=1){
        const L=clamp(level,1,3);
        if(kind===TOWER_TYPES.PENCIL)     return { range:120+10*L, dmg:6+2*L,  fireRate:600-30*L };
        if(kind===TOWER_TYPES.ERASER)     return { range:135+12*L, dmg:12+4*L, fireRate:880-40*L };
        if(kind===TOWER_TYPES.CALCULATOR) return { range:150+14*L, dmg:8+1*L,  fireRate:380-15*L, chain:2+(L-1) };
        if(kind===TOWER_TYPES.RULER)      return { range:190+22*L, dmg:10+3*L, fireRate:760-60*L, pierce:1+L };
        return { range:100, dmg:5, fireRate:800 };
      }
      function kindLabel(kind, level){
        if(kind===TOWER_TYPES.RULER)      return ["Ruler","Yardstick","Tape Measure"][level-1]||"Ruler";
        if(kind===TOWER_TYPES.PENCIL)     return ["Pencil","Pen","Marker"][level-1]||"Pencil";
        if(kind===TOWER_TYPES.ERASER)     return ["Eraser","Board Eraser","Giant Sponge"][level-1]||"Eraser";
        if(kind===TOWER_TYPES.CALCULATOR) return ["Calculator","Sci Calc","Graphing Calc"][level-1]||"Calculator";
        return kind;
      }
      const BASE_COST = { PENCIL:20, ERASER:35, CALCULATOR:45, RULER:60 };
      function upgradeCost(level){ return 30 + level*35 }

      // classroom decor
      function ClassroomDecor(){
        return (
          <>
            <rect x={40} y={10} width={300} height={36} rx={6} fill="#083344" stroke="#052e2b" strokeWidth="2"/>
            <text x={190} y={34} textAnchor="middle" fontSize="16" fill="#bbf7d0">Room 207 — Geometry</text>
            {[...Array(6)].map((_,i)=>(<rect key={i} x={0} y={80+i*70} width={28} height={56} rx={4} fill="#3b82f6" stroke="#1d4ed8"/>))}
            {
              [{x:260,y:120},{x:420,y:120},{x:580,y:120},
               {x:260,y:260},{x:420,y:260},{x:580,y:260},
               {x:260,y:400},{x:420,y:400},{x:700,y:360}]
              .map((d,idx)=>(
                <g key={idx}>
                  <rect x={d.x} y={d.y} width={70} height={40} rx={6} fill="#f1f5f9" stroke="#94a3b8"/>
                  <circle cx={d.x+10} cy={d.y+36} r={3} fill="#64748b"/>
                </g>
              ))
            }
            <ellipse cx={830} cy={420} rx={70} ry={28} fill="#fde68a" opacity="0.5"/>
          </>
        );
      }

      // tower sprites
      function TowerSprite({ kind, level=1, x, y, scale=1, opacity=1 }){
        const s = scale;
        if(kind === TOWER_TYPES.PENCIL){
          return (
            <g opacity={opacity} transform={`translate(${x-12*s},${y-12*s}) scale(${s})`}>
              <rect x={2} y={6} width={20} height={12} rx={2} fill="#f59e0b" stroke="#92400e"/>
              <polygon points="22,6 30,12 22,18" fill="#fde68a" stroke="#92400e"/>
              <polygon points="30,12 32,12 30,11" fill="#111"/>
            </g>
          );
        }
        if(kind === TOWER_TYPES.ERASER){
          return (
            <g opacity={opacity} transform={`translate(${x-14*s},${y-10*s}) scale(${s})`}>
              <rect x={0} y={0} width={28} height={20} rx={6} fill="#fecdd3" stroke="#fb7185"/>
              <rect x={10} y={0} width={18} height={20} rx={6} fill="#fdf2f8" stroke="#f472b6"/>
            </g>
          );
        }
        if(kind === TOWER_TYPES.CALCULATOR){
          return (
            <g opacity={opacity} transform={`translate(${x-14*s},${y-18*s}) scale(${s})`}>
              <rect x={0} y={0} width={28} height={36} rx={4} fill="#e5e7eb" stroke="#9ca3af"/>
              <rect x={4} y={4} width={20} height={8} rx={2} fill="#d1fae5" stroke="#10b981"/>
              {[...Array(6)].map((_,i)=>{const r=Math.floor(i/3), c=i%3;
                return <rect key={i} x={4+c*7} y={16+r*7} width={5} height={5} rx={1} fill="#fff" stroke="#9ca3af"/>})}
            </g>
          );
        }
        // Ruler / upgrades
        return (
          <g opacity={opacity} transform={`translate(${x-18*s},${y-6*s}) scale(${s})`}>
            <rect x={0} y={0} width={36} height={12} rx={2} fill="#fde68a" stroke="#f59e0b"/>
            {[...Array(8)].map((_,i)=><line key={i} x1={4+i*4} y1={2} x2={4+i*4} y2={i%2?6:10} stroke="#b45309" strokeWidth="1"/>)}
          </g>
        );
      }

      function App(){
        // STARTING COINS LOWERED HERE:
        const [coins,setCoins]=useState(40);
        const [lives,setLives]=useState(20);
        const [wave,setWave]=useState(1);
        const [inWave,setInWave]=useState(false);

        const [speed,setSpeed]=useState(1); // 1 or 2 (2x speed toggle)

        const [towers,setTowers]=useState([]);
        const [enemies,setEnemies]=useState([]);
        const [projectiles,setProjectiles]=useState([]);

        const [selectedKind,setSelectedKind]=useState(null);
        const [drag,setDrag]=useState(null); // {kind,x,y,valid}

        const mapRef=useRef(null);
        const pending=useRef(null);

        // spawn waves (interval scales with speed)
        useEffect(()=>{
          let timer;
          if(inWave){
            let i=0; const schedule=[]; const count=10+wave*2;
            for(let k=0;k<count;k++){
              const r=Math.random(); let type=ENEMY_TYPES.HOMEWORK;
              if(wave>=3 && r>0.7)  type=ENEMY_TYPES.QUIZ;
              if(wave>=6 && r>0.85) type=ENEMY_TYPES.TEST;
              if(wave%7===0 && k===count-1) type=ENEMY_TYPES.FINAL;
              schedule.push(type);
            }
            const interval = 600 / speed; // faster spawns at 2x
            timer=setInterval(()=>{
              if(i>=schedule.length){ clearInterval(timer); setTimeout(()=>setInWave(false),1500); return; }
              const type=schedule[i++]; const st=enemyStats(type,wave);
              setEnemies(prev=>[...prev,{id:crypto.randomUUID(), t:0, hp:st.hp, type}]);
            }, interval);
          }
          return ()=>clearInterval(timer);
        },[inWave,wave,speed]);

        // game loop
        useEffect(()=>{
          let last=performance.now(), raf;
          const step=(now)=>{
            const dt=(now-last)/1000; last=now;

            // enemies move (speed multiplier)
            setEnemies(prev=>{
              const out=[];
              for(const e of prev){
                const st=enemyStats(e.type,wave);
                const tNext=e.t + st.speed*dt*0.12*speed; // move faster at 2x
                if(tNext>=1) setLives(L=>Math.max(0, L-(e.type===ENEMY_TYPES.FINAL?5:1)));
                else out.push({...e,t:tNext});
              }
              return out;
            });

            // towers fire (fireRate shrinks with speed)
            setTowers(prev=>{
              const nowMs=performance.now();
              const ens=enemies.map(e=>({...e,pos:pointAtT(PATH,e.t)}));
              const newP=[];
              const upd=prev.map(tw=>{
                const st=baseTowerStats(tw.kind,tw.level);
                const adjustedRate = Math.max(50, st.fireRate / speed);
                if(!tw.lastShot || nowMs - tw.lastShot > adjustedRate){
                  let target=null, maxT=-1;
                  for(const e of ens){
                    const pos=e.pos;
                    if(distance({x:tw.x,y:tw.y},pos)<=st.range){
                      if(e.t>maxT){ maxT=e.t; target=e; }
                    }
                  }
                  if(target){
                    const ang=Math.atan2(target.pos.y-tw.y, target.pos.x-tw.x);
                    const projSpeed = 320 * speed;
                    newP.push({id:crypto.randomUUID(), x:tw.x,y:tw.y, vx:Math.cos(ang)*projSpeed, vy:Math.sin(ang)*projSpeed, dmg:st.dmg, pierce:st.pierce||0, chain:st.chain||0});
                    return {...tw, lastShot:nowMs};
                  }
                }
                return tw;
              });
              if(newP.length) setProjectiles(p=>[...p,...newP]);
              return upd;
            });

            // projectiles
            setProjectiles(prev=>{
              const out=[]; const ens=enemies.map(e=>({...e,pos:pointAtT(PATH,e.t)}));
              for(const p of prev){
                const nx=p.x+p.vx*dt, ny=p.y+p.vy*dt; let hit=-1;
                for(let i=0;i<ens.length;i++){ if(distance({x:nx,y:ny},ens[i].pos)<14){ hit=i; break; } }
                if(hit>=0){
                  const eHit=ens[hit];
                  setEnemies(arr=>{
                    const copy=[...arr]; const idx=copy.findIndex(x=>x.id===eHit.id);
                    if(idx>=0){
                      const type=copy[idx].type, newHp=copy[idx].hp - p.dmg;
                      if(newHp<=0){ const st=enemyStats(type,wave); copy.splice(idx,1); setCoins(c=>c+st.reward); }
                      else copy[idx]={...copy[idx], hp:newHp};
                    }
                    return copy;
                  });
                  if(p.pierce&&p.pierce>0) out.push({...p,x:nx,y:ny,pierce:p.pierce-1});
                  else if(p.chain&&p.chain>0){
                    const others=ens.filter(e=>e.id!==eHit.id); let best=null,bestD=1e9;
                    for(const e of others){ const d=distance({x:nx,y:ny},e.pos); if(d<80&&d<bestD){ best=e; bestD=d; } }
                    if(best){ const ang=Math.atan2(best.pos.y-ny, best.pos.x-nx); out.push({...p,x:nx,y:ny, vx:Math.cos(ang)*320*speed, vy:Math.sin(ang)*320*speed, chain:p.chain-1}); }
                  }
                } else if(nx<-20||ny<-20||nx>MAP_W+20||ny>MAP_H+20){
                  // offscreen
                } else out.push({...p,x:nx,y:ny});
              }
              return out;
            });

            raf=requestAnimationFrame(step);
          };
          raf=requestAnimationFrame(step);
          return ()=>cancelAnimationFrame(raf);
        },[enemies,wave,speed]);

        // wave advance
        useEffect(()=>{ if(!inWave && enemies.length === 0){ setWave(w=>w+1); setCoins(c=>c+30);} },[inWave,enemies.length]);
        useEffect(()=>{ if(lives<=0) alert("Class dismissed! The Exams reached your desk. Reload to try again."); },[lives]);

        function beginWave(){ if(!inWave) setInWave(true) }
        function toggleSpeed(){ setSpeed(s=> s===1 ? 2 : 1); }

        // drag & place
        function canPlaceAt(kind, x, y){
          if (x<24 || x>MAP_W-24 || y<24 || y>MAP_H-24) return false;
          const nearPath = PATH.some((_,i)=>{
            if(i===PATH.length-1) return false;
            const A=PATH[i], B=PATH[i+1]; const ABx=B.x-A.x, ABy=B.y-A.y;
            const t=clamp(((x-A.x)*ABx + (y-A.y)*ABy)/(ABx*ABx + ABy*ABy),0,1);
            const proj={x:A.x+ABx*t, y:A.y+ABy*t};
            return distance({x,y},proj) < 40;
          });
          if(nearPath) return false;
          for(const t of towers){ if(distance({x,y},{x:t.x,y:t.y})<34) return false; }
          return true;
        }

        function startDrag(kind){ setSelectedKind(kind); setDrag({ kind, x: MAP_W/2, y: MAP_H/2, valid:false }); }
        function onBoardMove(e){
          if(!drag) return;
          const rect=mapRef.current.getBoundingClientRect();
          const x=e.clientX - rect.left, y=e.clientY - rect.top;
          setDrag(d=> d ? ({...d, x, y, valid: canPlaceAt(d.kind,x,y) && coins >= BASE_COST[d.kind] }) : d);
        }
        function onBoardClick(){
          if(!drag) return;
          const {kind,x,y,valid}=drag; if(!valid) return;
          const cost=BASE_COST[kind]; if(coins<cost) return;
          setCoins(c=>c-cost);
          setTowers(arr=>[...arr,{id:crypto.randomUUID(), x,y, kind, level:1, lastShot:0}]);
          setDrag(null); setSelectedKind(null);
        }
        function cancelDrag(){ if(drag){ setDrag(null); setSelectedKind(null); } }

        // upgrades (instant, no questions)
        function requestUpgrade(tower){
          const cost=upgradeCost(tower.level);
          if(tower.level>=3) return;
          if(coins<cost) return;
          setCoins(c=>c-cost);
          setTowers(arr=>arr.map(t=> t.id===tower.id ? {...t, level: clamp(t.level+1,1,3)} : t));
        }

        const pathPolyline=useMemo(()=> PATH.map(p=>`${p.x},${p.y}`).join(" "), []);

        return (
          <div className="w-full min-h-screen text-gray-900 p-4">
            <div className="max-w-[1200px] mx-auto">
              <h1 className="text-2xl font-extrabold tracking-tight">📚 Classroom Defense — Math Game v2</h1>
              <p className="text-sm text-gray-700">Drag to place towers. Click a tower to upgrade (no questions for now).</p>

              <div className="mt-3 flex items-center gap-3 flex-wrap">
                <div className="px-3 py-2 rounded-xl bg-white shadow border">💰 Study Points: <b>{formatCoins(coins)}</b></div>
                <div className="px-3 py-2 rounded-xl bg-white shadow border">❤️ Lives: <b>{lives}</b></div>
                <div className="px-3 py-2 rounded-xl bg-white shadow border">📈 Wave: <b>{wave}</b></div>

                <button className={`px-4 py-2 rounded-xl shadow text-white ${inWave?"bg-gray-400":"bg-emerald-600 hover:bg-emerald-700"}`}
                        onClick={beginWave} disabled={inWave}>
                  {inWave?"Wave Running…":"Start Wave"}
                </button>

                <button className="px-4 py-2 rounded-xl shadow bg-indigo-600 hover:bg-indigo-700 text-white"
                        onClick={toggleSpeed}>
                  ⏩ Speed: {speed}x
                </button>
              </div>

              {/* Build bar */}
              <div className="mt-3 grid grid-cols-2 sm:grid-cols-4 gap-2">
                {Object.values(TOWER_TYPES).map(kind=>(
                  <button key={kind} onClick={()=>startDrag(kind)}
                          className={`border rounded-xl p-3 bg-white shadow hover:shadow-md transition ${selectedKind===kind?"ring-2 ring-blue-500":""}`}>
                    <div className="flex items-center gap-2">
                      <svg width="28" height="28"><g transform="translate(14,14)"><TowerSprite kind={kind} x={0} y={0} scale={0.9}/></g></svg>
                      <div className="font-bold">{kindLabel(kind,1)}</div>
                    </div>
                    <div className="text-xs text-gray-600 mt-1">Cost: {BASE_COST[kind]}</div>
                    <div className="text-xs text-gray-500">
                      {(()=>{const s=baseTowerStats(kind,1); return `Rng ${Math.floor(s.range)} / Dmg ${s.dmg} / ROF ${Math.max(200,s.fireRate)}ms`})()}
                    </div>
                    <div className="text-[10px] text-emerald-700 mt-1">Drag onto board to place</div>
                  </button>
                ))}
              </div>

              {/* Board */}
              <div className="mt-4 relative rounded-3xl border shadow overflow-hidden">
                <svg ref={mapRef} width={MAP_W} height={MAP_H}
                     onMouseMove={onBoardMove} onClick={onBoardClick} onMouseLeave={cancelDrag}
                     className="block cursor-crosshair">
                  {/* Floor tiles */}
                  <defs>
                    <pattern id="tiles" width="24" height="24" patternUnits="userSpaceOnUse">
                      <rect width="24" height="24" fill="#fafafa"/>
                      <path d="M 0 24 L 24 0" stroke="#f1f5f9" strokeWidth="1"/>
                    </pattern>
                  </defs>
                  <rect x={0} y={0} width={MAP_W} height={MAP_H} fill="url(#tiles)"/>

                  {/* decor */}
                  <ClassroomDecor/>

                  {/* Hallway path */}
                  <polyline points={pathPolyline} fill="none" stroke="#cbd5e1" strokeWidth="30" strokeLinejoin="round" strokeLinecap="round"/>
                  <polyline points={pathPolyline} fill="none" stroke="#64748b" strokeWidth="6" strokeLinejoin="round" strokeLinecap="round"/>

                  {/* Base / Desk */}
                  <g>
                    <rect x={820} y={330} width={64} height={64} rx={12} fill="#fff7ed" stroke="#fb923c" strokeWidth="3"/>
                    <text x={852} y={364} textAnchor="middle" fontSize="12">Desk</text>
                  </g>

                  {/* Towers */}
                  {towers.map(t=>(
                    <g key={t.id} onClick={(e)=>{ e.stopPropagation(); requestUpgrade(t); }} className="cursor-pointer">
                      <TowerSprite kind={t.kind} level={t.level} x={t.x} y={t.y}/>
                      {[...Array(t.level)].map((_,i)=> <circle key={i} cx={t.x-10+i*6} cy={t.y+16} r="2" fill="#334155" />)}
                    </g>
                  ))}

                  {/* Enemies */}
                  {enemies.map(e=>{
                    const pos=pointAtT(PATH,e.t);
                    let emoji="📄"; if(e.type===ENEMY_TYPES.QUIZ) emoji="❓"; if(e.type===ENEMY_TYPES.TEST) emoji="📘"; if(e.type===ENEMY_TYPES.FINAL) emoji="📚";
                    return (
                      <g key={e.id}>
                        <text x={pos.x} y={pos.y} fontSize="20" textAnchor="middle" dominantBaseline="middle">{emoji}</text>
                        <rect x={pos.x-16} y={pos.y-24} width="32" height="4" fill="#fee2e2" rx="2"/>
                        <rect x={pos.x-16} y={pos.y-24} width={clamp((e.hp/enemyStats(e.type,wave).hp)*32,0,32)} height="4" fill="#ef4444" rx="2"/>
                      </g>
                    );
                  })}

                  {/* Projectiles */}
                  {projectiles.map(p=> (<circle key={p.id} cx={p.x} cy={p.y} r="3" fill="#111827" />))}

                  {/* Drag ghost & placement ring */}
                  {drag && (
                    <g pointerEvents="none">
                      <circle cx={drag.x} cy={drag.y} r={baseTowerStats(drag.kind,1).range}
                              fill="none" stroke={drag.valid?"#22c55e":"#ef4444"}
                              strokeDasharray="6 6" strokeWidth="2" opacity="0.7"/>
                      <TowerSprite kind={drag.kind} x={drag.x} y={drag.y} opacity={0.6}/>
                    </g>
                  )}
                </svg>
              </div>

              <div className="mt-3 text-xs text-gray-600">
                Tip: Drag to place. Click a tower to upgrade. Use ⏩ to play at 2× speed.
              </div>
            </div>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<App/>);
    </script>
  </body>
</html>
